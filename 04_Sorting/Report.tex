\documentclass{article}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{geometry}
\usepackage{kotex}
\usepackage{amsmath,amssymb}
\usepackage{minted}
\usepackage{tikz}
\usepackage{lipsum}
\title{정렬 알고리즘 성능 비교}
\date{%
	2018.1 자료구조 과제 04%
%	\today%
}
\author{%
2017-12878 박승원%
}
\definecolor{mintedbackground}{rgb}{0.97,0.97,0.97}
\newmintedfile[javacode]{java}{
	bgcolor=mintedbackground,
	linenos=true,
	%	numbersep=5pt,
	tabsize=4,
	fontsize=\small,
	frame=leftline,
	% adapted from KTS 10th book
	breaklines=true,
	breakbefore={/\space\\\[\{},
	breakafter={/\space,\]\}},
	breakindent=2em,tabsize=4,
	breakaftersymbolpre={},
	breakbeforesymbolpre={},
	breakbeforesymbolpost={},
	breaksymbolleft={\tiny\ensuremath{\hookrightarrow}},
	breaksymbolright={},
}

\begin{document}
	\maketitle
	\begin{abstract}
		이 문서에서는 Bubble Sort, Insertion Sort, Heap Sort, Merge Sort,
		Quick Sort, Radix Sort와 같은 정렬 알고리즘의 동작 방식을 설명하고,
		주어진 크기의 배열을 정렬하는데에 소요되는 시간을 측정하고 분석하여
		각 알고리즘의 성능을 비교한다.
	\end{abstract}

 	\section{동작 방식}
 	
 	\subsection{Bubble Sort}
 	Bubble Sort는 배열의 모든 원소가 정렬될 때까지(line 5--13)
 	맨 앞에서부터 이웃한 두 원소를 비교(line 8)하여,
 	순서가 맞지 않을 경우 바꿔주기(line 9)를 반복하여 정렬하는 알고리즘이다.
 	
	\javacode{java-files/bubble.java}
	\clearpage
	
	\subsection{Insertion Sort}
	Insertion Sort는 매 순간 모든 원소가 정렬된 상태를 유지하며,
	새로운 원소가 추가될 때마다 그 원소가 들어갈 자리를 찾아(line 4--11)
	insert하는 알고리즘이다.
	
	\javacode{java-files/insertion.java}
	\clearpage
	
	\subsection{Heap Sort}
	Heap Sort는 heap이라는 자료구조를 활용한다.%
	\footnote{
		여기에서는 길이 n인 배열만을 사용하기 위해
		heap의 루트 노드의 인덱스를 0으로 두었다.
		따라서 인덱스가 $ i $인 노드의 두 자식 노드는
		인덱스가 $ 2i+1, 2i+2 $ (line 2, 3)이다.
	}
	우선, 주어진 배열을 이용하여 heap을 만들기 위해 
	자식 노드가 있는 모든 노드, 즉 $ n/2-1 $ 부터 0까지의
	인덱스를 가진 노드들 대해 \texttt{percolateDown}
	과정을 수행한다. (line 17--20)
	
	여기에서 \texttt{percolateDown} 과정은,
	한 노드의 값이 그의 자식노드들 중 큰 값(line 5--8)보다
	작을 경우 둘의 위치를 바꿔주기를 반복(line 9--12)하는 방식으로
	heap의 성질을 만족시키기 위해
	삽입/변경된 특정 노드를 heap의 아래쪽으로 내려보내는 과정이다.
	
	그 다음, heap의 루트 노드를 가장 마지막 인덱스의 원소와 바꾼다. (line 24)
	그 루트 노드에 있던 값은 이제까지 다룬 heap의 최대 원소이므로 더 이상
	다루지 않는다.
	이제 가장 마지막 인덱스에 있다가 루트 노드로 올라온 원소를 \texttt{percolateDown}
	해주면 다시 heap이 되고, 여기에서 또 다시 루트 노드를 빼가기를 반복하면
	배열의 모든 원소가 정렬된다.

	\javacode{java-files/heap.java}
	\clearpage
	
	\subsection{Merge Sort}
	Merge Sort에서는 배열의 크기가 1이 될 때까지 이등분(line 5, 6)하여 각각을 정렬하고,
	그 둘을 정렬된 배열로 병합하는 분할정복 알고리즘이다.
	
	두 배열의 맨 앞의 원소들을 비교하여 작은 값을 병합될 임시 배열에 넣고,
	이를 하나의 배열이 빌 때까지 반복한다.
	하나의 배열이 비고 나면 다른 한 배열에 남아있는 모든 원소를 임시 배열에 넣어주면
	임시 배열은 두 배열을 병합한, 정렬된 배열이 된다.
	
	\javacode{java-files/merge.java}
	\clearpage
	
	\subsection{Quick Sort}
	Quick Sort에서는 배열의 임의의 위치에 있는 원소 하나%
	\footnote{여기에서는 맨 뒤의 원소를 사용하고 있다: line 2}를 기준으로 삼아,
	배열을 그 기준보다 작은 원소들 / 큰 원소들로 이루어진 두 개의 배열로 나누기를
	배열의 크기가 1이 될 때까지 반복한다.
	
	아래의 코드에서 \texttt{partition} 함수는 주어진 구간의 부분배열에 대해
	기준점보다 작은 원소들을 앞쪽으로, 큰 원소들을 뒤쪽으로 배치하고
	둘의 구분 지점을 \texttt{int}형으로 리턴하는 함수다.
	
	
	\javacode{java-files/quick.java}
	\clearpage
	
	\subsection{Radix Sort}
	Radix Sort는 정수들로 이루어진 배열에 대해서만 사용할 수 있는 정렬 알고리즘이다.
	배열의 원소들을 4진법으로 나타내었을 때, 가장 작은 자리수에 대해 값이 0, 1, 2, 3인
	원소들을 하나씩 각각 임시 배열 \texttt{bucket}에 넣는다. 그 후 각각의 \texttt{bucket}에서
	모든 원소들을 다시 원래의 배열에 넣고, 이를 더 큰 자리수에 대해 계속해서 반복하면 된다.
	
	주어진 조건에서는 수가 \texttt{int}형으로 주어지기 때문에, 음의 값을 처리하기 위해
	모든 배열에 2147483648을 더하고, \texttt{Long}형으로 수들을 다뤘다.
	

	\javacode{java-files/radix.java}
	\clearpage
	
	\section{동작 시간 분석}
	
	
\end{document}